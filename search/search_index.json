{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Welcome to the Llama documentation! Llama stands for Lua Library for Immutable Data , and it has a ton of utilities for working with Lua tables without mutating them. It's a very simple library, so there isn't much else to say about it! Why immutability is important \u00b6 At first glance, immutability may seem like extra work in return for nothing, but immutability can seriously shrink your code complexity! In any application with state, mutations to the state are not immediately apparent, which can will cause bugs later on during development. Immutability is very good for tracking change to the state by making use of reference equality. If the current state is not the same object as the previous state, then you know that the state has changed, and can react accordingly! With this, immutability has an added bonus of being able to keep a \"history\" of state changes, which lets you do all sorts of cool things such as backtracking state (useful in hunting for bugs). In comparison, tracking mutable state changes is a nightmare!","title":"Home"},{"location":"#home","text":"Welcome to the Llama documentation! Llama stands for Lua Library for Immutable Data , and it has a ton of utilities for working with Lua tables without mutating them. It's a very simple library, so there isn't much else to say about it!","title":"Home"},{"location":"#why-immutability-is-important","text":"At first glance, immutability may seem like extra work in return for nothing, but immutability can seriously shrink your code complexity! In any application with state, mutations to the state are not immediately apparent, which can will cause bugs later on during development. Immutability is very good for tracking change to the state by making use of reference equality. If the current state is not the same object as the previous state, then you know that the state has changed, and can react accordingly! With this, immutability has an added bonus of being able to keep a \"history\" of state changes, which lets you do all sorts of cool things such as backtracking state (useful in hunting for bugs). In comparison, tracking mutable state changes is a nightmare!","title":"Why immutability is important"},{"location":"api-reference/","text":"API Reference \u00b6 Constants \u00b6 None \u00b6 As Lua dictionaries cannot distinguish between a value not being present and a value of nil , Llama.None exists to represent values that should be interpreted as nil . This is especially useful when removing values with Dictionary.merge . Dictionary \u00b6 Dictionaries are tables with key-value pairs. Constructors \u00b6 fromLists \u00b6 Llama.Dictionary.fromLists(keys, values) -> dictionary Returns a new dictionary constructed from keys and values . The lists are expected to be the same size. Example: local keys = { \"foo\" , \"bar\" , \"baz\" } local values = { 1 , 2 , 3 } Llama . Dictionary . fromLists ( keys , values ) Results: { foo = 1 , bar = 2 , baz = 3 , } Copying \u00b6 copy \u00b6 Llama.Dictionary.copy(dictionary) -> dictionary Returns a shallow copy of dictionary . copyDeep \u00b6 Llama.Dictionary.copyDeep(dictionary) -> dictionary Returns a deep copy of dictionary . Warning Deep copying is more expensive than shallow copying and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary. Comparing \u00b6 equals \u00b6 Llama.Dictionary.equals(...dictionaries) -> result Returns whether all dictionaries have shallow value equality. equalsDeep \u00b6 Llama.Dictionary.equalsDeep(...dictionaries) -> result Returns whether all dictionaries have deep value equality. Warning Deep comparison is more expensive than shallow comparison. Only use it when absolutely necessary. Persistent changes \u00b6 merge \u00b6 Llama.Dictionary.merge(...dictionaries) -> dictionary Returns a new dictionary with all of the entries of dictionaries merged together. Later entries replace older ones, and Llama.None can be used to remove values. Aliases join Example: local a = { key = \"value\" , foo = \"bar\" , removeMe = 0 , } local b = { removeMe = Llama . None , addMe = 1 , } Llama . Dictionary . merge ( a , b ) Results: { key = \"value\" , foo = \"bar\" , addMe = 1 , } mergeDeep \u00b6 Llama.Dictionary.mergeDeep(...dictionaries) -> dictionary Returns a new dictionary with all of the entries of dictionaries deeply merged together. Later entries replace older ones, and Llama.None can be used to remove values. Aliases joinDeep Example: local a = { key = \"value\" , foo = \"bar\" , dictionary = { foo = \"foo\" , bar = \"bar\" , }, removeMe = 0 , } local b = { removeMe = Llama . None , addMe = 1 , dictionary = { baz = \"baz\" , }, } Llama . Dictionary . mergeDeep ( a , b ) Results: { key = \"value\" , foo = \"bar\" , addMe = 1 , dictionary = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , }, } Warning Deep merging is more expensive than shallow merging and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary. removeKey \u00b6 Llama.Dictionary.removeKey(dictionary, key) -> dictionary Returns a new dictionary with the entry at key is removed from dictionary . removeKeys \u00b6 Llama.Dictionary.removeKeys(dictionary, ...keys) -> dictionary Returns new dictionary with entries at keys are removed from dictionary . removeValue \u00b6 Llama.Dictionary.removeValue(dictionary, value) -> dictionary Returns a new dictionary where any entry with value are removed from dictionary . removeValues \u00b6 Llama.Dictionary.removeValues(dictionary, ...values) -> dictionary Returns a new dictionary where any entry with any values are removed from dictionary . set \u00b6 Llama.Dictionary.set(dictionary, key, value) -> dictionary Returns a new dictionary with the entry at key in dictionary is set to value . update \u00b6 Llama.Dictionary.update(dictionary, key[, updater[, callback]]) -> dictionary Returns a new dictionary with the entry at key is updated by updater . If the entry does not exist, callback is invoked and the entry is created from its return value. updater and callback are expected to have the following signatures: updater(value, key) -> value callback(key) -> value Example: local dictionary = { foo = \"foo\" , bar = \"bar\" , } local function fooify ( value ) return \"foo\" .. value end Llama . Dictionary . update ( dictionary , \"bar\" , fooify ) Llama . Dictionary . update ( dictionary , \"baz\" , fooify , function () return \"baz\" end ) Results: { foo = \"foo\" , bar = \"foobar\" , } { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } Sequence algorithms \u00b6 filter \u00b6 Llama.Dictionary.filter(dictionary, filterer) -> dictionary Returns a new dictionary with only the entries of dictionary for which filterer returns a truthy. filterer is expected to have the following signature: filterer(value, key) -> result Example: local dictionary = { foo1 = \"foo\" , foo2 = \"foo\" , bar = \"foo\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . filter ( dictionary , onlyFoo ) Results: { foo1 = \"foo\" , foo2 = \"foo\" , } flip \u00b6 Llama.Dictionary.flip(dictionary) -> dictionary Returns a new dictionary with the keys and values of dictionary swapped. Example: local dictionary = { foo = \"oof\" , bar = \"rab\" , baz = \"zab\" , } Llama . Dictionary . flip ( dictionary ) Results: { oof = \"foo\" , rab = \"bar\" , zab = \"baz\" , } map \u00b6 Llama.Dictionary.map(dictionary, mapper) -> dictionary Returns a new dictionary with the values (and keys) of dictionary mapped over using mapper . mapper is expected to have the following signature: mapper(value, key) -> value[, key] Example: local dictionary = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function fooify ( value ) return \"foo\" .. value end Llama . Dictionary . map ( dictionary , fooify ) Results: { foo = \"foofoo\" , bar = \"foobar\" , baz = \"foobaz\" , } Reading values \u00b6 has \u00b6 Llama.Dictionary.has(dictionary, key) -> result Returns whether dictionary has a value at the key . includes \u00b6 Llama.Dictionary.includes(dictionary, value) -> result Returns whether dictionary includes a value . Conversion \u00b6 keys \u00b6 Llama.Dictionary.keys(dictionary) -> list Returns a list of dictionary 's keys. values \u00b6 Llama.Dictionary.values(dictionary) -> list Returns a list of dictionary 's values. Reducing \u00b6 count \u00b6 Llama.Dictionary.count(dictionary[, predicate]) -> result Returns the number of entries in dictionary for which predicate returns a truthy. If predicate is not provided, count simply counts all of the entries in dictionary (useful since #dictionary does not give the number of dictionary entries, only the number of list entries). predicate is expected to have the following signature: predicate(value, key) -> result Example: local dictionary = { foo1 = \"foo\" , foo2 = \"foo\" , bar1 = \"bar\" , bar2 = \"bar\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . count ( dictionary , onlyFoo ) Results: 2 every \u00b6 Llama.Dictionary.every(dictionary, predicate) -> result Returns whether predicate returns a truthy for all of dictionary 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { foo1 = \"foo\" , foo2 = \"foo\" , } local b = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . every ( a , onlyFoo ) Llama . Dictionary . every ( b , onlyFoo ) Results: true false some \u00b6 Llama.Dictionary.some(dictionary, predicate) -> result Returns whether predicate returns a truthy for any of dictionary 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { bar1 = \"bar\" , bar2 = \"bar\" , } local b = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . some ( a , onlyFoo ) Llama . Dictionary . every ( b , onlyFoo ) Results: false true Combination \u00b6 flatten \u00b6 Llama.Dictionary.flatten(dictionary[, depth]) -> dictionary Returns a new dictionary with dictionary 's entries flattened to depth or as deeply as possible if depth is not provided. Example: local dictionary = { foo = \"foo\" , foobar = { bar = \"bar\" , barbaz = { baz = \"baz\" , } } } Llama . Dictionary . flatten ( dictionary ) Results: { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } List \u00b6 Lists are tables with index-value pairs. Constructors \u00b6 create \u00b6 Llama.List.create(count, value) -> list Creates a new list of count value s. Copying \u00b6 copy \u00b6 Llama.List.copy(list) -> list Returns a shallow copy of list . copyDeep \u00b6 Llama.List.copyDeep(list) -> list Returns a deep copy of list . Warning Deep copying is more expensive than shallow copying and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary. Comparing \u00b6 equals \u00b6 Llama.List.equals(...lists) -> result Returns whether all lists have shallow value equality. equalsDeep \u00b6 Llama.List.equalsDeep(...lists) -> result Returns whether all lists have deep value equality. Warning Deep comparison is more expensive than shallow comparison. Only use it when absolutely necessary. Persistent changes \u00b6 concat \u00b6 Llama.List.concat(...lists) -> list Returns a concatenation of all of the lists in lists . Aliases join Example: local a = { 1 , 2 , 3 } local b = { 4 , 5 , 6 } Llama . List . concat ( a , b ) Results: { 1 , 2 , 3 , 4 , 5 , 6 } concatDeep \u00b6 Llama.List.concatDeep(...lists) -> list Returns a concatenation of all of the lists in lists with their sublists deep copied. Aliases joinDeep Warning Deep concatenating is more expensive than shallow concatenating and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary. insert \u00b6 Llama.List.insert(list, index, ...values) -> list Returns a new list with values inserted at index of list . If index is 0 or negative, insert inserts at index relative to the end of list . push \u00b6 Llama.List.push(list, ...values) -> list Returns copy of list with values appended to the end of list . Aliases append pop \u00b6 Llama.List.pop(list[, numPops]) -> list Returns copy of list with numPops values popped off the end of list . removeIndex \u00b6 Llama.List.removeIndex(list, index) -> list Returns a new list where the entry in list at index is removed. If index is 0 or negative, removeIndex removes at index relative to the end of list . removeIndices \u00b6 Llama.List.removeIndices(list, ...indices) -> list Returns a new list where all entries in list at indices is removed. If an index is 0 or negative, removeIndex removes at the index relative to the end of list . removeValue \u00b6 Llama.List.removeValue(list, value) -> list Returns a new list with all entries of list with value removed. removeValues \u00b6 Llama.List.removeValues(list, ...values) -> list Returns a new list with all entries of list with any values removed. set \u00b6 Llama.List.set(list, index, value) -> list Returns a new list with index in list set to the value . If index is 0 or negative, set sets at index relative to the end of list . shift \u00b6 Llama.List.shift(list[, numPlaces]) -> list Returns new list with numPlaces values shifted off the beginning of list . Example: local list = { \"foo\" , \"bar\" , \"baz\" } Llama . List . shift ( list ) Results: { \"bar\" , \"baz\" } unshift \u00b6 Llama.List.unshift(list, ...values) -> list Returns new list with values prepended to the beginning of list . Example: local list = { \"baz\" } Llama . List . unshift ( list , \"foo\" , \"bar\" ) Results: { \"foo\" , \"bar\" , \"baz\" } update \u00b6 Llama.List.update(list, index[, updater[, callback]]) -> list Returns a new list with the entry at index being updated by updater . If the entry does not exist, callback is invoked and the entry is created from its return value. updater and callback are expected to have the following signatures: updater(value, index) -> value callback(index) -> value Example: local list = { \"foo\" , \"bar\" } local function fooify ( value ) return \"foo\" .. value end Llama . List . update ( list , 2 , fooify ) Llama . List . update ( list , 3 , fooify , function () return \"baz\" end ) Results: { \"foo\" , \"foobar\" } { \"foo\" , \"bar\" , \"baz\" } Sequence algorithms \u00b6 filter \u00b6 Llama.List.filter(list, filterer) -> list Returns a new list with only the entries of list for which filterer returns a truthy. filterer is expected to have the following signature: filterer(value, index) -> result Example: local list = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . filter ( list , onlyFoo ) Results: { \"foo\" , \"foo\" } map \u00b6 Llama.List.map(list, mapper) -> list Returns a new list with the values of list mapped over using mapper . mapper is expected to have the following signature: mapper(value, index) -> value Example: local list = { \"foo\" , \"bar\" , \"baz\" } local function fooify ( value ) return \"foo\" .. value end Llama . List . map ( list , fooify ) Results: { \"foofoo\" , \"foobar\" , \"foobaz\" } reverse \u00b6 Llama.List.reverse(list) -> list Returns a new list with the entries of list reversed. Example: local list = { 1 , 2 , 3 } Llama . List . reverse ( list ) Results: { 3 , 2 , 1 } sort \u00b6 Llama.list.sort(list[, comparator]) -> list Returns a new list with the entries of list sorted by comparator if given. comparator should return true if the first argument should come before the second, and false otherwise. comparator is expected to have the following signature: comparator(a, b) -> result zip \u00b6 Llama.list.zip(...lists) -> list Returns a new list of lists \"zipped\" together. The length of list is the length of the shortest provided list. Example: local a = { \"foo\" , \"bar\" , \"baz\" } local b = { 1 , 2 , 3 , 4 } Llama . List . zip ( a , b ) Results: { { \"foo\" , 1 }, { \"bar\" , 2 }, { \"baz\" , 3 }, } zipAll \u00b6 Llama.list.zipAll(...lists) -> list Returns a new list of lists \"zipped\" together. zipAll zips as much as possible, filling in nil values with Llama.None Example: local a = { \"foo\" , \"bar\" , \"baz\" } local b = { 1 , 2 , 3 , 4 } Llama . List . zipAll ( a , b ) Results: { { \"foo\" , 1 }, { \"bar\" , 2 }, { \"baz\" , 3 }, { Llama . None , 4 }, } Creating subsets \u00b6 slice \u00b6 Llama.List.slice(list[, from[, to]]) -> list Returns a new list sliced from list . If from is not provided, slice slices from the beginning of list . If to is not provided, slice slices to the end of list . Example: local list = { 1 , 2 , 3 , 4 , 5 } Llama . List . slice ( list , 1 , 3 ) { 1 , 2 , 3 } Reading values \u00b6 first \u00b6 Llama.List.first(list) -> result Returns the first value in list . last \u00b6 Llama.List.last(list) -> result Returns the last value in list . includes \u00b6 Llama.List.includes(list, value) -> result Returns whether list includes a value . Finding a value \u00b6 find \u00b6 Llama.List.find(list, value[, from]) -> index Returns the first index from from if provided for which list has value . If from is 0 or negative, find searches from from relative to the end of list . findLast \u00b6 Llama.List.findLast(list, value[, from]) -> index Returns the last index from from if provided for which list has value . If from is 0 or negative, findLast searches from from relative to the end of list . findWhere \u00b6 Llama.List.findWhere(list, predicate[, from]) -> index Returns the first index from from if provided for which list 's value satisfies predicate . If from is 0 or negative, findWhere searches from from relative to the end of list . predicate is expected to have the following signature: predicate(value, index) -> result findWhereLast \u00b6 Llama.List.findWhereLast(list, predicate[, from]) -> index Returns the last index from from if provided for which list 's value satisfies predicate . If from is 0 or negative, findWhereLast searches from from relative to the end of list . predicate is expected to have the following signature: predicate(value, index) -> result Conversion \u00b6 toSet \u00b6 Llama.List.toSet(list) -> list Returns a new set created from list . Reducing \u00b6 count \u00b6 Llama.List.count(list[, predicate]) -> result Returns the number of entries in list for which predicate returns a truthy. If no predicate is provided, count simply counts all of the entries in list . predicate is expected to have the following signature: predicate(value, index) -> result Example: local list = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . count ( list , onlyFoo ) Results: 2 every \u00b6 Llama.List.every(list, predicate) -> result Returns whether predicate returns a truthy for all of list 's entries. predicate is expected to have the following signature: predicate(value, index) -> result Example: local a = { \"foo\" , \"foo\" } local b = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . every ( a , onlyFoo ) Llama . List . every ( b , onlyFoo ) Results: true false some \u00b6 Llama.List.some(list, predicate) -> result Returns whether predicate returns a truthy for any of list 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { \"bar\" , \"bar\" } local b = { \"foo\" , \"bar\" , \"baz\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . some ( a , onlyFoo ) Llama . List . some ( b , onlyFoo ) Results: false true reduce \u00b6 Llama.List.reduce(list, reducer[, initialReduction]) -> value Reduces list to a single value, from left to right. If initialReduction is not provided, reduce uses the first value in list . reducer is expected to have the following signature: reducer(reduction, value, key) -> reduction Example: local list = { 1 , 2 , 3 } local function add ( reduction , value ) return reduction = reduction + value end Llama . List . reduce ( list , add ) Results: 6 reduceRight \u00b6 Llama.List.reduceRight(list, reducer[, initialReduction]) -> value Reduces list to a single value, from right to left. If initialReduction is not provided, reduceRight uses the last value in list . reducer is expected to have the following signature: reducer(reduction, value, key) -> reduction Example: local list = { 1 , 2 , 3 } local function subtract ( reduction , value ) return reduction = reduction - value end Llama . List . reduceRight ( list , subtract ) Results: 0 Combination \u00b6 flatten \u00b6 Llama.List.flatten(list[, depth]) -> list Returns a new list with all of list 's entries flattened to depth or as deeply as possible if depth is not provided. Example: local list = { \"foo\" , { \"bar\" , { \"baz\" , } } } Llama . List . flatten ( list ) Results: { \"foo\" , \"bar\" , \"baz\" } splice \u00b6 Llama.List.splice(list, from, to, ...values) -> list Returns a new list with values replacing the values between from and to in list . Example: local list = { \"foo\" , 2 , 3 } Llama . List . splice ( list , 2 , 3 , \"bar\" , \"baz\" ) Results: { \"foo\" , \"bar\" , \"baz\" } Set \u00b6 Sets are tables where each value may only occur once. Constructors \u00b6 fromList \u00b6 Llama.Set.fromList(list) -> set Creates a set from list . Example: local list = { \"foo\" , \"bar\" , \"baz\" } Llama . Set . fromList ( list ) Results: { foo = true , bar = true , baz = true , } Copying \u00b6 copy \u00b6 Llama.Set.copy(set) -> set Returns a shallow copy of set . Comparing \u00b6 isSubset \u00b6 Llama.Set.isSubset(subset, superset) -> result Returns whether subset is a subset of superset . Example: local a = { foo = true , bar = true , } local b = { foo = true , bar = true , baz = true , } Llama . Set . isSubset ( a , b ) Llama . Set . isSubset ( b , a ) Results: true false isSuperset \u00b6 Llama.Set.isSuperset(superset, subset) -> result Returns whether superset is a superset of subset . Example: local a = { foo = true , bar = true , baz = true , } local b = { foo = true , bar = true , } Llama . Set . isSuperset ( a , b ) Llama . Set . isSuperset ( b , a ) Results: true false Persistent changes \u00b6 add \u00b6 Llama.Set.add(set, ...values) -> set Returns a new set with values added to set . Example: local set = { foo = true , bar = true , } Llama . Set . add ( set , \"baz\" ) Results: { foo = true , bar = true , baz = true , } subtract \u00b6 Llama.Set.subtract(set, ...values) -> set Returns a new set with values subtracted from set . Example: local set = { foo = true , bar = true , baz = true , } Llama . Set . subtract ( set , \"baz\" ) Results: { foo = true , bar = true , } union \u00b6 Llama.Set.union(...sets) -> set Returns a new set with all of the values of sets combined. Example: local a = { foo = true , bar = true , } local b = { bar = true , baz = true , } Llama . Set . union ( a , b ) Results: { foo = true , bar = true , baz = true , } intersection \u00b6 Llama.Set.intersection(...sets) -> set Returns a new set with only the values of sets that intersect. Example: local a = { foo = true , bar = true , } local b = { bar = true , baz = true , } Llama . Set . intersection ( a , b ) Results: { bar = true , } Sequence algorithms \u00b6 filter \u00b6 Llama.Set.filter(set, filterer) -> set Returns a new set with only the entries of the set for which the filterer returns a truthy. filterer is expected to have the following signature: filterer(value) -> result Example: local set = { [ 1 ] = true , [ 2 ] = true , [ 3 ] = true , [ 4 ] = true , [ 5 ] = true , } local function onlyEvens ( value ) return value % 2 == 0 end Llama . Set . filter ( set , onlyEvens ) Results: { [ 2 ] = true , [ 4 ] = true , } map \u00b6 Llama.Set.map(set, mapper) -> set Returns a new set with the values (and keys) of dictionary mapped using the mapper. mapper is expected to have the following signature: mapper(value) -> value Example: local set = { foo = true , bar = true , baz = true , } local function fooify ( value ) return \"foo\" .. value end Llama . Set . map ( set , fooify ) Results: { foofoo = true , foobar = true , foobaz = true , } Reading values \u00b6 has \u00b6 Llama.Set.has(set, value) -> result Returns whether set has value . equalObjects \u00b6 Llama.equalObjects(...objects) -> result Returns whether the items have reference equality. isEmpty \u00b6 Llama.isEmpty(table) -> result Returns whether the table is empty.","title":"API Reference"},{"location":"api-reference/#api-reference","text":"","title":"API Reference"},{"location":"api-reference/#constants","text":"","title":"Constants"},{"location":"api-reference/#none","text":"As Lua dictionaries cannot distinguish between a value not being present and a value of nil , Llama.None exists to represent values that should be interpreted as nil . This is especially useful when removing values with Dictionary.merge .","title":"None"},{"location":"api-reference/#dictionary","text":"Dictionaries are tables with key-value pairs.","title":"Dictionary"},{"location":"api-reference/#constructors","text":"","title":"Constructors"},{"location":"api-reference/#fromlists","text":"Llama.Dictionary.fromLists(keys, values) -> dictionary Returns a new dictionary constructed from keys and values . The lists are expected to be the same size. Example: local keys = { \"foo\" , \"bar\" , \"baz\" } local values = { 1 , 2 , 3 } Llama . Dictionary . fromLists ( keys , values ) Results: { foo = 1 , bar = 2 , baz = 3 , }","title":"fromLists"},{"location":"api-reference/#copying","text":"","title":"Copying"},{"location":"api-reference/#copy","text":"Llama.Dictionary.copy(dictionary) -> dictionary Returns a shallow copy of dictionary .","title":"copy"},{"location":"api-reference/#copydeep","text":"Llama.Dictionary.copyDeep(dictionary) -> dictionary Returns a deep copy of dictionary . Warning Deep copying is more expensive than shallow copying and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary.","title":"copyDeep"},{"location":"api-reference/#comparing","text":"","title":"Comparing"},{"location":"api-reference/#equals","text":"Llama.Dictionary.equals(...dictionaries) -> result Returns whether all dictionaries have shallow value equality.","title":"equals"},{"location":"api-reference/#equalsdeep","text":"Llama.Dictionary.equalsDeep(...dictionaries) -> result Returns whether all dictionaries have deep value equality. Warning Deep comparison is more expensive than shallow comparison. Only use it when absolutely necessary.","title":"equalsDeep"},{"location":"api-reference/#persistent-changes","text":"","title":"Persistent changes"},{"location":"api-reference/#merge","text":"Llama.Dictionary.merge(...dictionaries) -> dictionary Returns a new dictionary with all of the entries of dictionaries merged together. Later entries replace older ones, and Llama.None can be used to remove values. Aliases join Example: local a = { key = \"value\" , foo = \"bar\" , removeMe = 0 , } local b = { removeMe = Llama . None , addMe = 1 , } Llama . Dictionary . merge ( a , b ) Results: { key = \"value\" , foo = \"bar\" , addMe = 1 , }","title":"merge"},{"location":"api-reference/#mergedeep","text":"Llama.Dictionary.mergeDeep(...dictionaries) -> dictionary Returns a new dictionary with all of the entries of dictionaries deeply merged together. Later entries replace older ones, and Llama.None can be used to remove values. Aliases joinDeep Example: local a = { key = \"value\" , foo = \"bar\" , dictionary = { foo = \"foo\" , bar = \"bar\" , }, removeMe = 0 , } local b = { removeMe = Llama . None , addMe = 1 , dictionary = { baz = \"baz\" , }, } Llama . Dictionary . mergeDeep ( a , b ) Results: { key = \"value\" , foo = \"bar\" , addMe = 1 , dictionary = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , }, } Warning Deep merging is more expensive than shallow merging and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary.","title":"mergeDeep"},{"location":"api-reference/#removekey","text":"Llama.Dictionary.removeKey(dictionary, key) -> dictionary Returns a new dictionary with the entry at key is removed from dictionary .","title":"removeKey"},{"location":"api-reference/#removekeys","text":"Llama.Dictionary.removeKeys(dictionary, ...keys) -> dictionary Returns new dictionary with entries at keys are removed from dictionary .","title":"removeKeys"},{"location":"api-reference/#removevalue","text":"Llama.Dictionary.removeValue(dictionary, value) -> dictionary Returns a new dictionary where any entry with value are removed from dictionary .","title":"removeValue"},{"location":"api-reference/#removevalues","text":"Llama.Dictionary.removeValues(dictionary, ...values) -> dictionary Returns a new dictionary where any entry with any values are removed from dictionary .","title":"removeValues"},{"location":"api-reference/#set","text":"Llama.Dictionary.set(dictionary, key, value) -> dictionary Returns a new dictionary with the entry at key in dictionary is set to value .","title":"set"},{"location":"api-reference/#update","text":"Llama.Dictionary.update(dictionary, key[, updater[, callback]]) -> dictionary Returns a new dictionary with the entry at key is updated by updater . If the entry does not exist, callback is invoked and the entry is created from its return value. updater and callback are expected to have the following signatures: updater(value, key) -> value callback(key) -> value Example: local dictionary = { foo = \"foo\" , bar = \"bar\" , } local function fooify ( value ) return \"foo\" .. value end Llama . Dictionary . update ( dictionary , \"bar\" , fooify ) Llama . Dictionary . update ( dictionary , \"baz\" , fooify , function () return \"baz\" end ) Results: { foo = \"foo\" , bar = \"foobar\" , } { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , }","title":"update"},{"location":"api-reference/#sequence-algorithms","text":"","title":"Sequence algorithms"},{"location":"api-reference/#filter","text":"Llama.Dictionary.filter(dictionary, filterer) -> dictionary Returns a new dictionary with only the entries of dictionary for which filterer returns a truthy. filterer is expected to have the following signature: filterer(value, key) -> result Example: local dictionary = { foo1 = \"foo\" , foo2 = \"foo\" , bar = \"foo\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . filter ( dictionary , onlyFoo ) Results: { foo1 = \"foo\" , foo2 = \"foo\" , }","title":"filter"},{"location":"api-reference/#flip","text":"Llama.Dictionary.flip(dictionary) -> dictionary Returns a new dictionary with the keys and values of dictionary swapped. Example: local dictionary = { foo = \"oof\" , bar = \"rab\" , baz = \"zab\" , } Llama . Dictionary . flip ( dictionary ) Results: { oof = \"foo\" , rab = \"bar\" , zab = \"baz\" , }","title":"flip"},{"location":"api-reference/#map","text":"Llama.Dictionary.map(dictionary, mapper) -> dictionary Returns a new dictionary with the values (and keys) of dictionary mapped over using mapper . mapper is expected to have the following signature: mapper(value, key) -> value[, key] Example: local dictionary = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function fooify ( value ) return \"foo\" .. value end Llama . Dictionary . map ( dictionary , fooify ) Results: { foo = \"foofoo\" , bar = \"foobar\" , baz = \"foobaz\" , }","title":"map"},{"location":"api-reference/#reading-values","text":"","title":"Reading values"},{"location":"api-reference/#has","text":"Llama.Dictionary.has(dictionary, key) -> result Returns whether dictionary has a value at the key .","title":"has"},{"location":"api-reference/#includes","text":"Llama.Dictionary.includes(dictionary, value) -> result Returns whether dictionary includes a value .","title":"includes"},{"location":"api-reference/#conversion","text":"","title":"Conversion"},{"location":"api-reference/#keys","text":"Llama.Dictionary.keys(dictionary) -> list Returns a list of dictionary 's keys.","title":"keys"},{"location":"api-reference/#values","text":"Llama.Dictionary.values(dictionary) -> list Returns a list of dictionary 's values.","title":"values"},{"location":"api-reference/#reducing","text":"","title":"Reducing"},{"location":"api-reference/#count","text":"Llama.Dictionary.count(dictionary[, predicate]) -> result Returns the number of entries in dictionary for which predicate returns a truthy. If predicate is not provided, count simply counts all of the entries in dictionary (useful since #dictionary does not give the number of dictionary entries, only the number of list entries). predicate is expected to have the following signature: predicate(value, key) -> result Example: local dictionary = { foo1 = \"foo\" , foo2 = \"foo\" , bar1 = \"bar\" , bar2 = \"bar\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . count ( dictionary , onlyFoo ) Results: 2","title":"count"},{"location":"api-reference/#every","text":"Llama.Dictionary.every(dictionary, predicate) -> result Returns whether predicate returns a truthy for all of dictionary 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { foo1 = \"foo\" , foo2 = \"foo\" , } local b = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . every ( a , onlyFoo ) Llama . Dictionary . every ( b , onlyFoo ) Results: true false","title":"every"},{"location":"api-reference/#some","text":"Llama.Dictionary.some(dictionary, predicate) -> result Returns whether predicate returns a truthy for any of dictionary 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { bar1 = \"bar\" , bar2 = \"bar\" , } local b = { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , } local function onlyFoo ( value ) return value == \"foo\" end Llama . Dictionary . some ( a , onlyFoo ) Llama . Dictionary . every ( b , onlyFoo ) Results: false true","title":"some"},{"location":"api-reference/#combination","text":"","title":"Combination"},{"location":"api-reference/#flatten","text":"Llama.Dictionary.flatten(dictionary[, depth]) -> dictionary Returns a new dictionary with dictionary 's entries flattened to depth or as deeply as possible if depth is not provided. Example: local dictionary = { foo = \"foo\" , foobar = { bar = \"bar\" , barbaz = { baz = \"baz\" , } } } Llama . Dictionary . flatten ( dictionary ) Results: { foo = \"foo\" , bar = \"bar\" , baz = \"baz\" , }","title":"flatten"},{"location":"api-reference/#list","text":"Lists are tables with index-value pairs.","title":"List"},{"location":"api-reference/#constructors_1","text":"","title":"Constructors"},{"location":"api-reference/#create","text":"Llama.List.create(count, value) -> list Creates a new list of count value s.","title":"create"},{"location":"api-reference/#copying_1","text":"","title":"Copying"},{"location":"api-reference/#copy_1","text":"Llama.List.copy(list) -> list Returns a shallow copy of list .","title":"copy"},{"location":"api-reference/#copydeep_1","text":"Llama.List.copyDeep(list) -> list Returns a deep copy of list . Warning Deep copying is more expensive than shallow copying and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary.","title":"copyDeep"},{"location":"api-reference/#comparing_1","text":"","title":"Comparing"},{"location":"api-reference/#equals_1","text":"Llama.List.equals(...lists) -> result Returns whether all lists have shallow value equality.","title":"equals"},{"location":"api-reference/#equalsdeep_1","text":"Llama.List.equalsDeep(...lists) -> result Returns whether all lists have deep value equality. Warning Deep comparison is more expensive than shallow comparison. Only use it when absolutely necessary.","title":"equalsDeep"},{"location":"api-reference/#persistent-changes_1","text":"","title":"Persistent changes"},{"location":"api-reference/#concat","text":"Llama.List.concat(...lists) -> list Returns a concatenation of all of the lists in lists . Aliases join Example: local a = { 1 , 2 , 3 } local b = { 4 , 5 , 6 } Llama . List . concat ( a , b ) Results: { 1 , 2 , 3 , 4 , 5 , 6 }","title":"concat"},{"location":"api-reference/#concatdeep","text":"Llama.List.concatDeep(...lists) -> list Returns a concatenation of all of the lists in lists with their sublists deep copied. Aliases joinDeep Warning Deep concatenating is more expensive than shallow concatenating and forces you to resort to the more expensive equalsDeep for value equality checking. Only use it when absolutely necessary.","title":"concatDeep"},{"location":"api-reference/#insert","text":"Llama.List.insert(list, index, ...values) -> list Returns a new list with values inserted at index of list . If index is 0 or negative, insert inserts at index relative to the end of list .","title":"insert"},{"location":"api-reference/#push","text":"Llama.List.push(list, ...values) -> list Returns copy of list with values appended to the end of list . Aliases append","title":"push"},{"location":"api-reference/#pop","text":"Llama.List.pop(list[, numPops]) -> list Returns copy of list with numPops values popped off the end of list .","title":"pop"},{"location":"api-reference/#removeindex","text":"Llama.List.removeIndex(list, index) -> list Returns a new list where the entry in list at index is removed. If index is 0 or negative, removeIndex removes at index relative to the end of list .","title":"removeIndex"},{"location":"api-reference/#removeindices","text":"Llama.List.removeIndices(list, ...indices) -> list Returns a new list where all entries in list at indices is removed. If an index is 0 or negative, removeIndex removes at the index relative to the end of list .","title":"removeIndices"},{"location":"api-reference/#removevalue_1","text":"Llama.List.removeValue(list, value) -> list Returns a new list with all entries of list with value removed.","title":"removeValue"},{"location":"api-reference/#removevalues_1","text":"Llama.List.removeValues(list, ...values) -> list Returns a new list with all entries of list with any values removed.","title":"removeValues"},{"location":"api-reference/#set_1","text":"Llama.List.set(list, index, value) -> list Returns a new list with index in list set to the value . If index is 0 or negative, set sets at index relative to the end of list .","title":"set"},{"location":"api-reference/#shift","text":"Llama.List.shift(list[, numPlaces]) -> list Returns new list with numPlaces values shifted off the beginning of list . Example: local list = { \"foo\" , \"bar\" , \"baz\" } Llama . List . shift ( list ) Results: { \"bar\" , \"baz\" }","title":"shift"},{"location":"api-reference/#unshift","text":"Llama.List.unshift(list, ...values) -> list Returns new list with values prepended to the beginning of list . Example: local list = { \"baz\" } Llama . List . unshift ( list , \"foo\" , \"bar\" ) Results: { \"foo\" , \"bar\" , \"baz\" }","title":"unshift"},{"location":"api-reference/#update_1","text":"Llama.List.update(list, index[, updater[, callback]]) -> list Returns a new list with the entry at index being updated by updater . If the entry does not exist, callback is invoked and the entry is created from its return value. updater and callback are expected to have the following signatures: updater(value, index) -> value callback(index) -> value Example: local list = { \"foo\" , \"bar\" } local function fooify ( value ) return \"foo\" .. value end Llama . List . update ( list , 2 , fooify ) Llama . List . update ( list , 3 , fooify , function () return \"baz\" end ) Results: { \"foo\" , \"foobar\" } { \"foo\" , \"bar\" , \"baz\" }","title":"update"},{"location":"api-reference/#sequence-algorithms_1","text":"","title":"Sequence algorithms"},{"location":"api-reference/#filter_1","text":"Llama.List.filter(list, filterer) -> list Returns a new list with only the entries of list for which filterer returns a truthy. filterer is expected to have the following signature: filterer(value, index) -> result Example: local list = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . filter ( list , onlyFoo ) Results: { \"foo\" , \"foo\" }","title":"filter"},{"location":"api-reference/#map_1","text":"Llama.List.map(list, mapper) -> list Returns a new list with the values of list mapped over using mapper . mapper is expected to have the following signature: mapper(value, index) -> value Example: local list = { \"foo\" , \"bar\" , \"baz\" } local function fooify ( value ) return \"foo\" .. value end Llama . List . map ( list , fooify ) Results: { \"foofoo\" , \"foobar\" , \"foobaz\" }","title":"map"},{"location":"api-reference/#reverse","text":"Llama.List.reverse(list) -> list Returns a new list with the entries of list reversed. Example: local list = { 1 , 2 , 3 } Llama . List . reverse ( list ) Results: { 3 , 2 , 1 }","title":"reverse"},{"location":"api-reference/#sort","text":"Llama.list.sort(list[, comparator]) -> list Returns a new list with the entries of list sorted by comparator if given. comparator should return true if the first argument should come before the second, and false otherwise. comparator is expected to have the following signature: comparator(a, b) -> result","title":"sort"},{"location":"api-reference/#zip","text":"Llama.list.zip(...lists) -> list Returns a new list of lists \"zipped\" together. The length of list is the length of the shortest provided list. Example: local a = { \"foo\" , \"bar\" , \"baz\" } local b = { 1 , 2 , 3 , 4 } Llama . List . zip ( a , b ) Results: { { \"foo\" , 1 }, { \"bar\" , 2 }, { \"baz\" , 3 }, }","title":"zip"},{"location":"api-reference/#zipall","text":"Llama.list.zipAll(...lists) -> list Returns a new list of lists \"zipped\" together. zipAll zips as much as possible, filling in nil values with Llama.None Example: local a = { \"foo\" , \"bar\" , \"baz\" } local b = { 1 , 2 , 3 , 4 } Llama . List . zipAll ( a , b ) Results: { { \"foo\" , 1 }, { \"bar\" , 2 }, { \"baz\" , 3 }, { Llama . None , 4 }, }","title":"zipAll"},{"location":"api-reference/#creating-subsets","text":"","title":"Creating subsets"},{"location":"api-reference/#slice","text":"Llama.List.slice(list[, from[, to]]) -> list Returns a new list sliced from list . If from is not provided, slice slices from the beginning of list . If to is not provided, slice slices to the end of list . Example: local list = { 1 , 2 , 3 , 4 , 5 } Llama . List . slice ( list , 1 , 3 ) { 1 , 2 , 3 }","title":"slice"},{"location":"api-reference/#reading-values_1","text":"","title":"Reading values"},{"location":"api-reference/#first","text":"Llama.List.first(list) -> result Returns the first value in list .","title":"first"},{"location":"api-reference/#last","text":"Llama.List.last(list) -> result Returns the last value in list .","title":"last"},{"location":"api-reference/#includes_1","text":"Llama.List.includes(list, value) -> result Returns whether list includes a value .","title":"includes"},{"location":"api-reference/#finding-a-value","text":"","title":"Finding a value"},{"location":"api-reference/#find","text":"Llama.List.find(list, value[, from]) -> index Returns the first index from from if provided for which list has value . If from is 0 or negative, find searches from from relative to the end of list .","title":"find"},{"location":"api-reference/#findlast","text":"Llama.List.findLast(list, value[, from]) -> index Returns the last index from from if provided for which list has value . If from is 0 or negative, findLast searches from from relative to the end of list .","title":"findLast"},{"location":"api-reference/#findwhere","text":"Llama.List.findWhere(list, predicate[, from]) -> index Returns the first index from from if provided for which list 's value satisfies predicate . If from is 0 or negative, findWhere searches from from relative to the end of list . predicate is expected to have the following signature: predicate(value, index) -> result","title":"findWhere"},{"location":"api-reference/#findwherelast","text":"Llama.List.findWhereLast(list, predicate[, from]) -> index Returns the last index from from if provided for which list 's value satisfies predicate . If from is 0 or negative, findWhereLast searches from from relative to the end of list . predicate is expected to have the following signature: predicate(value, index) -> result","title":"findWhereLast"},{"location":"api-reference/#conversion_1","text":"","title":"Conversion"},{"location":"api-reference/#toset","text":"Llama.List.toSet(list) -> list Returns a new set created from list .","title":"toSet"},{"location":"api-reference/#reducing_1","text":"","title":"Reducing"},{"location":"api-reference/#count_1","text":"Llama.List.count(list[, predicate]) -> result Returns the number of entries in list for which predicate returns a truthy. If no predicate is provided, count simply counts all of the entries in list . predicate is expected to have the following signature: predicate(value, index) -> result Example: local list = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . count ( list , onlyFoo ) Results: 2","title":"count"},{"location":"api-reference/#every_1","text":"Llama.List.every(list, predicate) -> result Returns whether predicate returns a truthy for all of list 's entries. predicate is expected to have the following signature: predicate(value, index) -> result Example: local a = { \"foo\" , \"foo\" } local b = { \"foo\" , \"foo\" , \"bar\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . every ( a , onlyFoo ) Llama . List . every ( b , onlyFoo ) Results: true false","title":"every"},{"location":"api-reference/#some_1","text":"Llama.List.some(list, predicate) -> result Returns whether predicate returns a truthy for any of list 's entries. predicate is expected to have the following signature: predicate(value, key) -> result Example: local a = { \"bar\" , \"bar\" } local b = { \"foo\" , \"bar\" , \"baz\" } local function onlyFoo ( value ) return value == \"foo\" end Llama . List . some ( a , onlyFoo ) Llama . List . some ( b , onlyFoo ) Results: false true","title":"some"},{"location":"api-reference/#reduce","text":"Llama.List.reduce(list, reducer[, initialReduction]) -> value Reduces list to a single value, from left to right. If initialReduction is not provided, reduce uses the first value in list . reducer is expected to have the following signature: reducer(reduction, value, key) -> reduction Example: local list = { 1 , 2 , 3 } local function add ( reduction , value ) return reduction = reduction + value end Llama . List . reduce ( list , add ) Results: 6","title":"reduce"},{"location":"api-reference/#reduceright","text":"Llama.List.reduceRight(list, reducer[, initialReduction]) -> value Reduces list to a single value, from right to left. If initialReduction is not provided, reduceRight uses the last value in list . reducer is expected to have the following signature: reducer(reduction, value, key) -> reduction Example: local list = { 1 , 2 , 3 } local function subtract ( reduction , value ) return reduction = reduction - value end Llama . List . reduceRight ( list , subtract ) Results: 0","title":"reduceRight"},{"location":"api-reference/#combination_1","text":"","title":"Combination"},{"location":"api-reference/#flatten_1","text":"Llama.List.flatten(list[, depth]) -> list Returns a new list with all of list 's entries flattened to depth or as deeply as possible if depth is not provided. Example: local list = { \"foo\" , { \"bar\" , { \"baz\" , } } } Llama . List . flatten ( list ) Results: { \"foo\" , \"bar\" , \"baz\" }","title":"flatten"},{"location":"api-reference/#splice","text":"Llama.List.splice(list, from, to, ...values) -> list Returns a new list with values replacing the values between from and to in list . Example: local list = { \"foo\" , 2 , 3 } Llama . List . splice ( list , 2 , 3 , \"bar\" , \"baz\" ) Results: { \"foo\" , \"bar\" , \"baz\" }","title":"splice"},{"location":"api-reference/#set_2","text":"Sets are tables where each value may only occur once.","title":"Set"},{"location":"api-reference/#constructors_2","text":"","title":"Constructors"},{"location":"api-reference/#fromlist","text":"Llama.Set.fromList(list) -> set Creates a set from list . Example: local list = { \"foo\" , \"bar\" , \"baz\" } Llama . Set . fromList ( list ) Results: { foo = true , bar = true , baz = true , }","title":"fromList"},{"location":"api-reference/#copying_2","text":"","title":"Copying"},{"location":"api-reference/#copy_2","text":"Llama.Set.copy(set) -> set Returns a shallow copy of set .","title":"copy"},{"location":"api-reference/#comparing_2","text":"","title":"Comparing"},{"location":"api-reference/#issubset","text":"Llama.Set.isSubset(subset, superset) -> result Returns whether subset is a subset of superset . Example: local a = { foo = true , bar = true , } local b = { foo = true , bar = true , baz = true , } Llama . Set . isSubset ( a , b ) Llama . Set . isSubset ( b , a ) Results: true false","title":"isSubset"},{"location":"api-reference/#issuperset","text":"Llama.Set.isSuperset(superset, subset) -> result Returns whether superset is a superset of subset . Example: local a = { foo = true , bar = true , baz = true , } local b = { foo = true , bar = true , } Llama . Set . isSuperset ( a , b ) Llama . Set . isSuperset ( b , a ) Results: true false","title":"isSuperset"},{"location":"api-reference/#persistent-changes_2","text":"","title":"Persistent changes"},{"location":"api-reference/#add","text":"Llama.Set.add(set, ...values) -> set Returns a new set with values added to set . Example: local set = { foo = true , bar = true , } Llama . Set . add ( set , \"baz\" ) Results: { foo = true , bar = true , baz = true , }","title":"add"},{"location":"api-reference/#subtract","text":"Llama.Set.subtract(set, ...values) -> set Returns a new set with values subtracted from set . Example: local set = { foo = true , bar = true , baz = true , } Llama . Set . subtract ( set , \"baz\" ) Results: { foo = true , bar = true , }","title":"subtract"},{"location":"api-reference/#union","text":"Llama.Set.union(...sets) -> set Returns a new set with all of the values of sets combined. Example: local a = { foo = true , bar = true , } local b = { bar = true , baz = true , } Llama . Set . union ( a , b ) Results: { foo = true , bar = true , baz = true , }","title":"union"},{"location":"api-reference/#intersection","text":"Llama.Set.intersection(...sets) -> set Returns a new set with only the values of sets that intersect. Example: local a = { foo = true , bar = true , } local b = { bar = true , baz = true , } Llama . Set . intersection ( a , b ) Results: { bar = true , }","title":"intersection"},{"location":"api-reference/#sequence-algorithms_2","text":"","title":"Sequence algorithms"},{"location":"api-reference/#filter_2","text":"Llama.Set.filter(set, filterer) -> set Returns a new set with only the entries of the set for which the filterer returns a truthy. filterer is expected to have the following signature: filterer(value) -> result Example: local set = { [ 1 ] = true , [ 2 ] = true , [ 3 ] = true , [ 4 ] = true , [ 5 ] = true , } local function onlyEvens ( value ) return value % 2 == 0 end Llama . Set . filter ( set , onlyEvens ) Results: { [ 2 ] = true , [ 4 ] = true , }","title":"filter"},{"location":"api-reference/#map_2","text":"Llama.Set.map(set, mapper) -> set Returns a new set with the values (and keys) of dictionary mapped using the mapper. mapper is expected to have the following signature: mapper(value) -> value Example: local set = { foo = true , bar = true , baz = true , } local function fooify ( value ) return \"foo\" .. value end Llama . Set . map ( set , fooify ) Results: { foofoo = true , foobar = true , foobaz = true , }","title":"map"},{"location":"api-reference/#reading-values_2","text":"","title":"Reading values"},{"location":"api-reference/#has_1","text":"Llama.Set.has(set, value) -> result Returns whether set has value .","title":"has"},{"location":"api-reference/#equalobjects","text":"Llama.equalObjects(...objects) -> result Returns whether the items have reference equality.","title":"equalObjects"},{"location":"api-reference/#isempty","text":"Llama.isEmpty(table) -> result Returns whether the table is empty.","title":"isEmpty"},{"location":"guide/installation/","text":"Installation \u00b6 There are a few ways to get started with Llama. Method 1: Import model file \u00b6 Download the .rbxmx model file from the latest release on the Llama releases page . Insert the model anywhere in a Roblox place! Method 2: Good ol' copy + paste \u00b6 Copy the src directory of Llama into your project. Rename it to Llama . Make sure you put t under the Llama directory. (this step will hopefully be resolved in the future by package managers or Luau type-checking) Use something like Rojo to sync your project to Roblox Studio! Method 3: Git submodule \u00b6 Navigate to where you want to keep your submodules in Git bash. Run git submodule add https://github.com/F-RDY/llama.git . Using something like Rojo , set up your project to sync Llama/src into Roblox Studio! Method 4: Package manager \u00b6 Coming Soon\u2122","title":"Installation"},{"location":"guide/installation/#installation","text":"There are a few ways to get started with Llama.","title":"Installation"},{"location":"guide/installation/#method-1-import-model-file","text":"Download the .rbxmx model file from the latest release on the Llama releases page . Insert the model anywhere in a Roblox place!","title":"Method 1: Import model file"},{"location":"guide/installation/#method-2-good-ol-copy-paste","text":"Copy the src directory of Llama into your project. Rename it to Llama . Make sure you put t under the Llama directory. (this step will hopefully be resolved in the future by package managers or Luau type-checking) Use something like Rojo to sync your project to Roblox Studio!","title":"Method 2: Good ol' copy + paste"},{"location":"guide/installation/#method-3-git-submodule","text":"Navigate to where you want to keep your submodules in Git bash. Run git submodule add https://github.com/F-RDY/llama.git . Using something like Rojo , set up your project to sync Llama/src into Roblox Studio!","title":"Method 3: Git submodule"},{"location":"guide/installation/#method-4-package-manager","text":"Coming Soon\u2122","title":"Method 4: Package manager"},{"location":"guide/usage/","text":"Usage \u00b6 Basic usage \u00b6 To use Llama, simply require it as a module from where you installed it! It is also recommended that you set Llama.Dictionary , Llama.List , and Llama.Set to their own variables; otherwise, you'll be typing a lot! -- Other modules... local Llama = require ( LlamaPath ) local Dictionary = Llama . Dictionary local List = Llama . List local Set = Llama . Set Usage with Roact and Rodux \u00b6 Rodux requires your state to be immutable, so Llama is a great choice for manipulating it! local function reducer ( state , action ) if action . type == \"Add\" then return Dictionary . merge ( state , { counter = counter + 1 }) elseif action . type == \"Subtract\" then return Dictionary . merge ( state , { counter = counter - 1 }) end end","title":"Usage"},{"location":"guide/usage/#usage","text":"","title":"Usage"},{"location":"guide/usage/#basic-usage","text":"To use Llama, simply require it as a module from where you installed it! It is also recommended that you set Llama.Dictionary , Llama.List , and Llama.Set to their own variables; otherwise, you'll be typing a lot! -- Other modules... local Llama = require ( LlamaPath ) local Dictionary = Llama . Dictionary local List = Llama . List local Set = Llama . Set","title":"Basic usage"},{"location":"guide/usage/#usage-with-roact-and-rodux","text":"Rodux requires your state to be immutable, so Llama is a great choice for manipulating it! local function reducer ( state , action ) if action . type == \"Add\" then return Dictionary . merge ( state , { counter = counter + 1 }) elseif action . type == \"Subtract\" then return Dictionary . merge ( state , { counter = counter - 1 }) end end","title":"Usage with Roact and Rodux"}]}